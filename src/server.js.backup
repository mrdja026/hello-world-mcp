#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  ErrorCode,
  McpError,
} from "@modelcontextprotocol/sdk/types.js";
import dotenv from "dotenv";
import express from "express";
import cors from "cors";
import { PerplexityTool } from "./tools/perplexity.js";
import { fetchJiraTicketFull } from "./jira-client.js";

// Load environment variables
dotenv.config();

// Configuration from environment variables
const JIRA_CONFIG = {
  baseUrl: process.env.JIRA_BASE_URL || "https://username.atlassian.net",
  email: process.env.JIRA_EMAIL,
  apiToken: process.env.JIRA_API_TOKEN,
};

class LocalMCPServer {
  constructor() {
    // Initialize tool instances
    this.perplexityTool = new PerplexityTool();

    // Declare tools in capabilities.tools
    this.server = new Server(
      { name: "local-mcp-server", version: "1.0.0" },
      {
        capabilities: {
          tools: {},
          resources: {},
        },
      }
    );

    // Handlers for MCP protocol methods
    this.server.setRequestHandler(ListToolsRequestSchema, async () =>
      this.handleListTools()
    );

    this.server.setRequestHandler(ListResourcesRequestSchema, async () =>
      this.handleListResources()
    );

    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) =>
      this.handleReadResource(request)
    );

    this.server.setRequestHandler(CallToolRequestSchema, async (request) =>
      this.handleCall(request)
    );
  }

  async handleListTools() {
    return {
      tools: [
        {
          name: "add_numbers",
          description: "Add multiple numbers together (minimum 2 numbers)",
          inputSchema: {
            type: "object",
            properties: {
              numbers: {
                type: "array",
                items: { type: "number" },
                minItems: 2,
                description: "Array of numbers to add together",
              },
            },
            required: ["numbers"],
          },
        },
        {
          name: "fetch_jira_ticket",
          description: "Fetch a JIRA ticket by its key (e.g., PROJ-123)",
          inputSchema: {
            type: "object",
            properties: {
              ticketKey: {
                type: "string",
                description: "JIRA ticket key (e.g., PROJ-123)",
                pattern: "^[A-Z]+-[0-9]+$",
              },
            },
            required: ["ticketKey"],
          },
        },
        {
          name: "fetch_ticket",
          description:
            "Fetch a JIRA ticket by its key (Lane B enhanced compatibility)",
          inputSchema: {
            type: "object",
            properties: {
              ticketKey: {
                type: "string",
                description: "JIRA ticket key (e.g., SCRUM-42)",
                pattern: "^[A-Z]+-[0-9]+$",
              },
            },
            required: ["ticketKey"],
          },
        },
        this.perplexityTool.getToolDefinition(),
      ],
    };
  }

  async handleListResources() {
    return {
      resources: [],
    };
  }

  async handleReadResource(request) {
    throw new McpError(ErrorCode.InvalidRequest, "No resources available");
  }

  async handleCall(request) {
    console.error("handleCall received:", JSON.stringify(request, null, 2));
    const { name, arguments: args, _auth } = request.params || {};
    console.error("Tool called:", name, args ? Object.keys(args) : "no args");

    if (!name) {
      throw new McpError(
        ErrorCode.InvalidRequest,
        "Missing tool name in request"
      );
    }

    try {
      switch (name) {
        case "add_numbers":
          return this.handleAddNumbers(args);
        case "fetch_jira_ticket":
        case "fetch_ticket": // Lane B compatibility alias
          return this.handleFetchJiraTicket(args);
        case "fetch_perplexity_data":
          return this.perplexityTool.execute(args, _auth);
        default:
          throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);
      }
    } catch (err) {
      console.error("Tool execution error:", err);
      if (err instanceof McpError) throw err;
      throw new McpError(ErrorCode.InternalError, err.message);
    }
  }

  async handleAddNumbers(args) {
    const { numbers } = args || {};
    if (!Array.isArray(numbers)) {
      throw new McpError(ErrorCode.InvalidParams, "Numbers must be an array");
    }
    if (numbers.length < 2) {
      throw new McpError(
        ErrorCode.InvalidParams,
        "At least 2 numbers are required"
      );
    }
    for (const n of numbers) {
      if (typeof n !== "number" || isNaN(n)) {
        throw new McpError(ErrorCode.InvalidParams, `Invalid number: ${n}`);
      }
    }
    const sum = numbers.reduce((a, b) => a + b, 0);
    return {
      content: [
        {
          type: "text",
          text: `Added ${numbers.length} numbers: ${numbers.join(
            " + "
          )} = ${sum}`,
        },
      ],
    };
  }

  async handleFetchJiraTicket(args) {
    const { ticketKey } = args || {};
    if (!ticketKey || typeof ticketKey !== "string") {
      throw new McpError(
        ErrorCode.InvalidParams,
        "Ticket key is required and must be a string"
      );
    }
    if (!/^[A-Z]+-[0-9]+$/.test(ticketKey)) {
      throw new McpError(
        ErrorCode.InvalidParams,
        "Invalid ticket key format. Expected format: PROJ-123"
      );
    }

    console.log(`Fetching JIRA ticket: ${ticketKey}`);

    try {
      // Use the enhanced JIRA client
      const ticketData = await fetchJiraTicketFull({
        baseUrl: JIRA_CONFIG.baseUrl,
        issueKey: ticketKey,
        auth: {
          email: JIRA_CONFIG.email,
          apiToken: JIRA_CONFIG.apiToken,
        },
      });

      console.log(`Successfully fetched JIRA ticket: ${ticketKey}`);

      // Format the comprehensive response using existing formatter
      const responseText = this.formatJiraTicketResponse(ticketData);

      return {
        content: [
          {
            type: "text",
            text: responseText,
          },
        ],
      };
    } catch (error) {
      console.error("Enhanced JIRA client error:", error.message);

      // Convert to MCP error format
      if (error.message.includes("not found")) {
        throw new McpError(ErrorCode.InvalidParams, error.message);
      } else if (
        error.message.includes("authentication") ||
        error.message.includes("access denied")
      ) {
        throw new McpError(ErrorCode.InvalidParams, error.message);
      } else {
        throw new McpError(ErrorCode.InternalError, error.message);
      }
    }
  }

  formatJiraTicketResponse(info) {
    let response = `JIRA Ticket: ${info.key}
═══════════════════════════════════════════════════════════════

BASIC INFORMATION:
• Title: ${info.summary}
• Type: ${info.issueType.name}
• Status: ${info.status.name} (${info.status.statusCategory})
• Priority: ${info.priority.name}
• Project: ${info.project.name} (${info.project.key})

PEOPLE:
• Assignee: ${info.assignee.displayName}
• Reporter: ${info.reporter.displayName}

TIMELINE:
• Created: ${new Date(info.created).toLocaleDateString()} ${new Date(
      info.created
    ).toLocaleTimeString()}
• Updated: ${new Date(info.updated).toLocaleDateString()} ${new Date(
      info.updated
    ).toLocaleTimeString()}`;

    if (info.duedate) {
      response += `\n• Due Date: ${new Date(
        info.duedate
      ).toLocaleDateString()}`;
    }
    if (info.resolutiondate) {
      response += `\n• Resolved: ${new Date(
        info.resolutiondate
      ).toLocaleDateString()}`;
    }

    response += `\n\nDESCRIPTION:
${info.description}`;

    if (info.resolution) {
      response += `\n\nRESOLUTION:
• Status: ${info.resolution.name}
• Details: ${info.resolution.description}`;
    }

    if (info.components.length > 0) {
      response += `\n\nCOMPONENTS:
${info.components
  .map((comp) => `• ${comp.name}: ${comp.description}`)
  .join("\n")}`;
    }

    if (info.fixVersions.length > 0) {
      response += `\n\nFIX VERSIONS:
${info.fixVersions
  .map((ver) => `• ${ver.name} (Released: ${ver.released ? "Yes" : "No"})`)
  .join("\n")}`;
    }

    if (info.labels.length > 0) {
      response += `\n\nLABELS:
${info.labels.join(", ")}`;
    }

    if (info.linkedIssues.length > 0) {
      response += `\n\nLINKED ISSUES:`;
      info.linkedIssues.forEach((link) => {
        if (link.inwardIssue) {
          response += `\n• ${link.type.inward}: ${link.inwardIssue.key} - ${link.inwardIssue.summary} (${link.inwardIssue.status})`;
        }
        if (link.outwardIssue) {
          response += `\n• ${link.type.outward}: ${link.outwardIssue.key} - ${link.outwardIssue.summary} (${link.outwardIssue.status})`;
        }
      });
    }

    if (info.parent) {
      response += `\n\nPARENT ISSUE:
• ${info.parent.key}: ${info.parent.summary} (${info.parent.status})`;
    }

    if (info.subtasks.length > 0) {
      response += `\n\nSUBTASKS:`;
      info.subtasks.forEach((subtask) => {
        response += `\n• ${subtask.key}: ${subtask.summary} (${subtask.status}) - ${subtask.assignee}`;
      });
    }

    if (info.timeTracking) {
      response += `\n\nTIME TRACKING:`;
      if (info.timeTracking.originalEstimate)
        response += `\n• Original Estimate: ${info.timeTracking.originalEstimate}`;
      if (info.timeTracking.remainingEstimate)
        response += `\n• Remaining: ${info.timeTracking.remainingEstimate}`;
      if (info.timeTracking.timeSpent)
        response += `\n• Time Spent: ${info.timeTracking.timeSpent}`;
    }

    if (info.storyPoints) {
      response += `\n\nSTORY POINTS: ${info.storyPoints}`;
    }

    response += `\n\nACTIVITY:
• Comments: ${info.commentsCount}
• Attachments: ${info.attachmentsCount}
• Watchers: ${info.watchersCount}
• Votes: ${info.votesCount}`;

    if (info.recentComments.length > 0) {
      response += `\n\nRECENT COMMENTS:`;
      info.recentComments.forEach((comment) => {
        response += `\n• ${comment.author} (${new Date(
          comment.created
        ).toLocaleDateString()}): ${comment.body.substring(0, 100)}${
          comment.body.length > 100 ? "..." : ""
        }`;
      });
    }

    return response;
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("Local MCP Server running on stdio");
  }

  // HTTP JSON-RPC endpoint for web integrations
  async startHttp(port = 4000) {
    const app = express();

    // Basic CORS for localhost only
    app.use(
      cors({
        origin: ["http://localhost:8080", "http://127.0.0.1:8080"],
        credentials: true,
      })
    );
    app.use(express.json());

    // Health check endpoint
    app.get("/health", (req, res) => {
      res.json({ status: "ok", transport: "http", stdio: false });
    });

    // Main MCP JSON-RPC endpoint
    app.post("/mcp", async (req, res) => {
      const { method, params, id = Date.now() } = req.body || {};

      // Optional simple auth via header
      const authToken = process.env.MCP_HTTP_TOKEN;
      if (authToken && req.headers.authorization !== `Bearer ${authToken}`) {
        return res.status(401).json({
          jsonrpc: "2.0",
          error: { code: -32001, message: "Unauthorized" },
          id,
        });
      }

      try {
        let result;
        switch (method) {
          case "tools/list":
          case "listTools":
            result = await this.handleListTools();
            break;
          case "tools/call":
          case "callTool":
            result = await this.handleCall({ params: params });
            break;
          case "resources/list":
            result = await this.handleListResources();
            break;
          case "resources/read":
          case "readResource":
            result = await this.handleReadResource({ params });
            break;
          default:
            return res.status(400).json({
              jsonrpc: "2.0",
              error: { code: -32601, message: `Unknown method: ${method}` },
              id,
            });
        }

        res.json({
          jsonrpc: "2.0",
          result,
          id,
        });
      } catch (error) {
        console.error("HTTP MCP error:", error);
        const isMcpError = error instanceof McpError;
        res.status(isMcpError ? 400 : 500).json({
          jsonrpc: "2.0",
          error: {
            code: isMcpError ? error.code : -32603,
            message: error.message || "Internal error",
          },
          id,
        });
      }
    });

    return new Promise((resolve, reject) => {
      const server = app.listen(port, "127.0.0.1", () => {
        console.error(`MCP HTTP server running on http://127.0.0.1:${port}`);
        resolve(server);
      });
      server.on("error", reject);
    });
  }
}

// Launch - support both stdio and HTTP modes
const mcpServer = new LocalMCPServer();

// Always start stdio transport
mcpServer.start().catch(console.error);

// Optionally start HTTP if MCP_HTTP_PORT is set
const httpPort = process.env.MCP_HTTP_PORT;
if (httpPort) {
  mcpServer.startHttp(parseInt(httpPort, 10)).catch(console.error);
}
